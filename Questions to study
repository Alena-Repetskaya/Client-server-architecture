HW
Client_Server
1) Прочиать про клиент-серверную архитектуру
В настоящий момент все еще не пришли к унифицироанному понятию про уровни клиент-серверной архитектуры.
Коротко помечу в свой конспект как я понимаю уровни со своими примерами.
По сути сейчас почти весь интернет представляет собой такую структуру.
Клиент - потребитель услуги. Отправляет request
Сервер - процесс предоставления услуг. Отправляет response
Клиент-серверная архитектура построена на протоколе передачи данных HTTP.
При этом клиент - это конечно "клиент", но если говорить более научным языком, то программа-клиент, которая запрашивает данные.
Клиент может быть как десктопное приложение, веб приложение. 
Сервер, это не просто отдельный компьютер (машина). Сервер это программа, которая обрабатывает запрсы от клиент-программы.
Клиентов может быть большое количество, и серверов в одной архитектуре тоже может быть много. 
Одноуровневая архитектура
Самый простой пример это сеть в Евроводосистемы. У нас было штук 10 клиентов, это компьютеры пользователей в нескольких кабенетах, 
а также тех, кто работал в удаленном формате. И был отдельный "обычный компьютер" сервер, на котором хранились общие документы.
При этом там стояло специфическое ПО, безопасность на более высоком уровне для защиты данных, обслуживание файлов автоматизировано.
Сервер при этом  не выполнял прикладных программ, только предоставлял доступ к данным. 
В целом это считается надежной системой, однако важно понимать для каких задач это нужно. 
Недостатки, если например нужно что-то синхронизировать на всех клиентских машинах, а их в архитектуре 100 шт.

Двухуровневая архитектура
Для меня это явный пример работы в компаниях по дополнительному обучению стоматологов и Интеллектуальный энергомониторинг.\
Так, обе эти компании использовали одинаковую CRM.
Каждая CRM настраивалась отдельно под нужды каждой компании, и сама по себе очень гибкая. Однако, если случались сбои в работе ПО,
то сбоила программа одинаково в обеих организациях. 
При этом, важно различать понятия 
thin klient fat server 
fat klient thin server
О чем это вообще?
Когда начались блокировки в связи с политической обстановкой, многие фирмы (конкретно знаю салон красоты в Минске)
потеряли доступ ко всем своим базам данных. Это большая проблема, т.к. они в один клик потеряли всю свою клиенскую базу.
В их случае был fat server. Если бы каким-то образом, данные собирались у них, а они только пользовались бы ПО (CRM) общей, 
то они бы по нажатию кнопочки  потеряли бы доступ к CRM но базы данных (в каком виде? Насколько читабельный вид?) были би им доступны.

Примеры толстых и тонких клиентов.
Все что, приложением отдельным устанавливается - скорее всего толстый клиент, а все, что в веб браузере - тонкий клиент
Преимущества этой системы, легко настраивать приложения, легко модифицировать, т.к. на сервере хранится сама программа.
Легко можно добавить новые клиент-машины в систему.

Однако сервера должно хватать на производительность на всех клиентов
Безопасность данных (как показано на примере выше). 
Все клиенты зависят от базы данных одного производителя.


Трехуровневая архитектура.
Клиенты с уставновленными приложениями
Сервер приложений
Через промежуточное программное обеспечение middlewere обращается к --> (за счет этого повышается производительность, гибкость работы)
БД, Сервер БД, файловыый сервер
Преимущества: целостность данных, защищенность базы данных от несанкционированного проникновения,
предоставляются права доступа к данным - ограничением в правах
недостатки: более сложная структура коммуникации между клиентом и сервером

Многоуровневая архитектура.
Почти то же самое, что и трехуровневая, но серверов приложений несколько.
Преимущества: гибкость
Недостатки: чем больше компонентов, тем сложнее наладить их работу

Преимущества архитектуры клиент-сервис: 
масштабируемость, количество клиентов и количество серверов
производительность, увеличивается скорость работы ресурсов общего пользования
безопасность, т.к. все данные на сервере, проще администрировать сервер, а не всех клиентов
независимость от платформы. Подробнее: клиент может быть на платформе андроид, айос, веб. А сервер на линукс.
нет дублирования кода, код хранится только на сервере.

Недостатки архитектуры клиент-сервис:
наличие единой точки отказа в небольших сетях с одним сервером. Отказал сервер, или сервер перегужен,
клиенты могут остаться без обслуживания. 

Также важно отметить, что сейчас появилось понятие Serverless Architecture - что подразумевает типа 
отсутствие сервера, но на самом деле сервер все также есть, просто он облачный. 
Клиент получает сервисы в виде абстрактной "функции как услуги" FaaS Funktion as a Service.

Если сервер многонагруженный, то несколько серверов + балансировщик, который помогает опеределять на какой сервер будет отправлен запрос
Может быть несколько баз данных по такому же принципу. Это называется горячий резерв.

Есть вариант, когда просто дублирующий сервер (БД) есть, но он не находится постоянно в работе, а включается, 
только если основной упал. Это называется холодный резерв. 
Кластер баз данных - копирование.

Так предотвращаем выход из строя. 

Сервер намного дороже, чем обычный компьютер.
Что делает тестировщик? В первую очередь тестирует "Клиента". 
Если есть доступ к серверу или базе данных, то там тоже можно смотреть. 

Тестирование безопасности/защищенности, это значит вклиниться в путь обмена данными, типа именно там тонкое звено. 
Именно там взломщики делают свои атаки.
Самый простой пример клиента это браузер. Мы в нем вводим какие-то HTTP запросы, а он отправляет дальше на сервера. 

2) Что ткое HTTP и HTTPS
Протокол - набор правил передачи информации. 
HyperText Transfer Protocol, «протокол передачи гипертекста».
Протокол предполагает использование клиент-серверной архитектуры.
Клиентское приложение формирует запрос и отрправляет его на сервер, серверное ПО обрабатывает запрос и 
формирует ответ. После чего передает его обратно клиенту. 
Благодаря протоколу HTTP обеспечивается работа всемирной паутины. 
Также HHTP может использоваться как "транспорт" для передачи информации для других протоколов пригладного
уровня (SOAP, XML-RPC)
API многих программных продуктов также использует HTTP для передачи данных (XML, JSON).
Передача данных по протоколу HyperText Transfer Protocol осущесвляется через TCP/IP-соединения.
Серверное ПО при этом обычно использует TCP-порт 80, хотя может использовать любой другой.

Есть расширение, которое реализует упаковку передаваемых данных в криптографический протокол SSL или TLS.
и HTTP становится HTTPS (HyperText Transfer Protocol Secure). Для таких соединений уже используется
TCP-порт 443. Благодаря HTTPS можно защитить данные от перехвата, и можно обеспечить защиту от атак
вида man-in-the-middle. 

Задачи такой не было, решила разобраться. Версии HTTP
Основной HTTP протокол, который сейчас используют имеет версию 1.1, однако также есть протокол
HTTP/2 который сделан на основе другого протокола SPDY (читается спиди). SPDY разрабатывался когда-то
в Google. на 2021 год 50% из самых популярных 10 млн сайтов поддерживаеют HTTP/2
Основные отличия версия:
в HTTP/1.1 все запросы и ответы в текстовом формате,
HTTP/2 использует двоичный уровень кадрирования для инкапсуляции всех сообщений в двоичном формате,
при это сохраняя семантику HTTP (методы, заголовки).
1.1 запрашивает страницу HTML. Если на ней содержатся ссылки на файлы CSS и JS, то они запрашиваются 
отдельными запросами клиентом. Это увеличивает время загрузки. 
Т.к. сервер заранее знает, что клиенту потребуются дополнительные файлы, сервер может сэкономить время
отправляя эти ресурсы прежде чем он их запросит.
HTTP/2 осуществляет механизм Server Push. Предоставляет ресурс до того, как клиент запросит его. 

Уже появился HTTP/3. 20% из 10 млн самых популярных сайтов поддерживают его. Поддерживает chrome, safari, firefox,

3) HTTP методы
Основная операция над ресурсом. 
Название метода чувствительно к регистру (CAPS LOCK).
Есть какая-то общая унификация методов, и желательно ей следовать.
Но при этом сервер может иметь свои особенные методы, но тогда в ошибках должно быть указано это.
Основные методы: 
GET - стандартный запрос от клиента (запрос содержимого), или можно начать какой-либо процесс.
HEAD - подобное на GET, но отправляется в случае, когда уже есть данные в кэше, проверить, не обновилось ли чего.
Ответ на метод HEAD не должен содержать тело.
POST - что-то отправить на сервер (например, данные пользователя в базу внести, сохранить). Также загрузка данных на сервер.
Возвращает статус 200 (Ok). В другом месте: добавление или замена данных.
PUT - это похоже на POST, но PUT Это когда создается новый ресурс. Возвращается статус 201 (Creatad)
В другом месте: регулярное обновление данных.
DELETE - Удаляет указанный ресурс
TRACE - клиент может увидеть какую информацию промежуточные серверы добавляют или изменяют в запросе.
CONNECT - преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно, чтобы содействовать 
установлению защищенного SSL-соединения через нешифрованный прокси.
Отличия между GET и POST.
GET отправляет скрипту всю собранную информацию формы как часть URL:
http://www.komtet.ru/script.php?login=admin&name=komtet
POST передает данные так, что пользователь сайта уже не видит передаваемые скрипту данные:
http://www.komtet.ru/script.php
Кроме того:
Количество информации, передаваемой GET через URL строку ограничено 2048 символами (минус служебная информация браузера);
Страницу, сгенерированную методом GET, можно добавить в закладки и поделиться ссылкой;
Sensitive data в таком открытом виде очевидно плохо влияют на безопасность;
Метод POST в отличие от метода GET позволяет передавать запросу файлы;
При использовании метода GET существует риск того, что поисковый робот может выполнить
тот или иной открытый запрос.
OPTIONS - покажет все доступные методы вес-сервера или конкретного ресурса.

методы делятся на три большие группы: 
Безопасные - не меняют данные, модно выполнять их в любой последовательности GET, HEAD, OPTIONS
Идемпотентные - при повторном выполнении результаты ожидаемо одинаковые GET, HEAD, PUT, DELETE, OPTIONS, TRACE
неидемпотентные - при повторном выполнении результаты будут отличаться POST, PATCH

4) HTTP статус коды сервера
трехзначное число. Набор кодов - стандарт. Клиент может и не знать все коды состояния, но обязан отреагировать
в соответствии с классом кода. Код состояния - часть первой строки ответа от сервера. 
Первая цифра - класс состояния - English 
100          - информационный  - Informational
200          - успех           - Success
300          - перенаправление - Redirection
400          - ошибка клиента  - Client Error
500          - ошибка сервера  - Server Error

Ошибка 404 - относится к клиенской, хотя по логике должна быть серверной. Почему? 
Объясняют это тем, что сервер работает, и готов вернуть страницу вответ на запрос, однако страницы
по запрашиваемому адресу у него попросту нет. и считается, что вины сервера в этом нет.
Ошибка 501 (метод запроса не поддерживается сервером и не может быть обработан) не может вернуться на методы GET и HEAD
т.е. все серверы должны отвечать что-то на эти два метода. Они обязательные. 

5) Что такое ядро браузера 
Браузер равно ядро + оболочка. Выделяют две составляющие ядра. Движок JS и движок Рендеринга. 
Или как в википедии написано Браузерный движок 'layout engine' - программа, которая преобразует 
содержимое вебстраниц (а это файлы HTML, XML, цифровые изображения) и информацию о форматировании
(CSS, XSL) в изображение с кнопочками, ссылочками, которые мы видим на экране. 
Обычно используется в веб-барузерах, почтовых клиентах и других программах (пока не могу придумать в каких?)
Раньше они были не отделимы от браузеров, а потом стали отдельными.

6) Какие браузеры какиие ядра используют
Chrome - Blink
Safari - WebKit
Яндекс.Браузер - Blink
Mozilla Firefox - Gecko ..в другом месте Quantum
Opera - Blink
Microsoft Edge - Blink 
Internet Explorer - Trident
TOR Browser
Blink - ответвление WebKit
Brave - Blink

7) Что такое API = Application Programming Interface = Программный интерфейс приложения
API - это некоторая прослойка между клиентом и сервером. 
API позволяет взаимодейтвовать двум программным приложениям на оговоренных правилах не залезая
в реализацию тех или иных функций, т.е. скрывается "внутреннее строение программ" 
У всех популярных продуктов есть открытая часть API. Так программисты, которые хотят каким-то образом
внедрить или взаимодействовать с этим продуктом смогут узнать, какие взаимодействия возможны. 
Интерфейсы упрощают жизнь, так, когда программисту нужно получить какой-то опционал от другого приложение,
ему не нужно будет изучать код других программистов, чтобы связать свой и чужой продукт. 
Это называется ИНКАПСУЛЯЦИЯ - сокрытие части функций ради упращения работы в целом. 
Программист должен знать какой процесс может выполнять программа используя API, какие данные он должен передать,
какие данные его программа получит от стороннего приложения. Что там происходит внутри стороннего
приложения программист не узнает. 

Современный API воспринимается как отдельный продукт - программу с выпуском новых версий, длительным
сроком поддержки. 
Теперь к созданию программных интерфейсов подходят как к созданию приложений. Все как для обычных приложений.
Идея, тестирование, разработка, контроль версий, документация для разработчиков. 

8) Что такое ендпоинты
Эндпоинты — неотъемлемая часть в работе API
Какая-то точка назначения)))))))) Конец пути. 

9) URL (URI, URL, URN)
URI - Uniform Resource Identifier - унифицированный идентификатор ресурса. Указывает где и как найти ресурс - это полный путь. URL + URN.
URL - Uniform Resourse Locator - определяет способ (http, https, fttp и др) + саму адресную строку текстом (адрес местонахождения сети) - без имени файла.
URN - Uniform Resourse Name - идентифицирует только название файла (последняя часть в адресной строке). может заканчиваться .html
Вообще на самом деле все адреса - это IP - двоичные, но для нашего удобства форматируется в текстовый формат. 

10) Идемпотентные HTTP методы
Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько 
раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера. Т.е. идемпотентный метод
не должен иметь никаких побочных эффектов (side-effects).

К идемпотентным методам относятся GET, HEAD, PUT, DELETE + все безопасные методы. 
Однако например, если использовать коаманду DELETE с функциональностью "удалить последнюю запись".
То при многократном повторении этой операции, можно удалить все записи.
Таже метод POST не относится к идемпотентным. 

11) Безопасные HTTP методы
Метод HTTP является безопасным, если он не меняет состояние сервера (только чтение).
GET, HEAD, OPTIONS. 
Все безопасные методы также являются идемпотентными. 
Но не все идемпотентные методы являются безопасными. 
Так PUT и DELETE меняют состояние сервера, но только один раз. 

12) Идентификация, Аутентификация, Авторизация
Идентификация - выявляется идентификатор, однозначно определяющий субъект в информационной системе.
То есть система распознала логин. 
Аутентификация - процедура проверки подлинности, например путем сравнения введенного им пароля с паролем, 
сохраненным в базе данных. (она сейчас часто двухфакторная, смс-ка или еще что-нибудь)
Авторизация - предоставление субъекту прав на выполнение определенных действий. (прим. читать почту)
К слову авторизация возможна без идентификации и аутентификации. 
Когда мы предоставляем доступ всем без логина/пароля. Например, к гугл документам. 

13) Что такое IP - internet protocol - уникальный числовой идентификатор устройства
в компьютерной сети, работающей по протоколу IP.
IPv4 - четыре десятичных числа от 0 до 255, разделенных точками (32 битное)
IPv6 - восемь четырехзначных шестнадцетеричных чисел, разделенных двоеточием (128 битное)
Если видим в адресе несколько двоеточий подряд, значит там были нули. Более одного такого пропуска
в адресе не допускается. 

IP адрес состоит из двух частей: номер сети, номер узла. 
Если мы говорим о локальной сети (изолированной), то администратор сети дожен выбрать 
из специально зарезервированных блоков вдресов (10.0.0.0/8, 172.16.0.0/12 или 192.168.0.0/16).


14) Что такое октеты в DNS
Сначала что такое DNS = Domain Name System - это технология, которая позволяет браузеру найти запрошенный
пользователем сайт по его имени. 
Кажому имени сайте ссответсвтует набор цифр формата
000.000.000.000 этот набор называется IP-адресом. 
Когда пользователь вводит в адресной строке (браузера) имя сайта, в это время компьютер запрашивает
IP-адрес этого сайта на специальном DNS-сервере и уже после получения корректного ответа открывает сам сайт. 

То есть DNS-сервер это как телефонная книга для нас, пользователей.
Мы знаем название сайтов буквами, браузер сам тоже не умеет расшифровывать. 
DNS-сервер это специализированный компьютер или группа компьютеров, которые хранят IP-адреса сайтов. 
В интернете много DNS-серверов, они есть у каждого провайдера и обслуживают их пользователей. 

Задача DNS-сервера - хранение информации о доменах и ее предоставление по запросу пользователей, а также
кеширование DNS-записей других серверов. 
Когда мы ввели название сайта в строку браузера происходит приблизительно следующее:
1) поиск в локальном файле настроек DNS (файл HOSTS). Если там нет -->
2) локальный DNS-сервер интернет-провайдера -->
3) DNS-сервер взаимодействует с другими DNS-серверами из региона, в котором находится запрошенный сайт.
4) После нескольких обращений к таким серверам локальный DNS-сервер получает искомое и отправляет данные в наш браузер.
--> Запрошенный сайт открывается.
При этом данные сохраняются на локальном сервере, что в будущем ускоряет работу. 
Процесс сохранения полученных ранее данных называется кэшированием. 
Однако этот кэш хранится не постоянно. Зависит от настроек сервера. 

Когда мы регистрируем новый сайт, в админке прописывается доменное имя. И так DNS-записи где-то через сутки
прописываются в локальном сервере, попадут в реестры прочих DNS-серверов. DNS-сайта активируется. 

Структура пакета DNS.

Header     = Заголовок         = состоит из 12 октет
Question   = Секция запросов   = здесь инфлормация для какого имени нужно разрешить записть DNS
Answer     = Секция ответа     = сервер дает ответ или несколько ответов на запрос
Authority  = Секция ответа об уполномоченных серверах = указыает с каких серверов взяли эту информацию
Additional = Секция ответа дополнительных записей = (они могут быть, а может и не быть)

Здесь еще много детализированной информации. 
https://xakinfo.ru/network_administration/dns-packet/


15) Что такое порт, сколько портов у Linux сервера

Порты это более точный адрес для соединения с сервером или клиентом. 
Портов огромное множество 1-65535. 
Чаще всего определенные программы занимают определенные порты, либо например передача почты, или передача файлов могут
иметь отдельно выделенные порты.
HTTP - TCP-порт 80
SMPT - пересылка почты TCP-25
FTP - передача файлов - TCP-21
DNS - протокол сопоставления доменных имен IP-адресам - UDP-порт 53.
Отличие TCP и UDP. TCP - проверяет, чтобы данные были получены (почта), а UDP - нет (UDP это игры, звонки через инет). Для этих задач
скорость важнее надежности.

номер порта выглядит как двоеточие+цифра в конце нашего URI адреса.  http://www.example.com:80/

Firewall - програмы, которые закрывают неиспользуемые порты, чтобы вирусные программы не подключались к компьютеру.
Для защиты от взлома и атаки. 

СПИСОК ВСЕХ ОТКРЫТЫХ ПОРТОВ можно посмотреть разными способами. 
$ sudo netstat –tulpn
$ sudo ss -tulpn

$ sudo watch netstat -tulpn  //"это в режиме реального времени"
$ sudo watch ss -tulpn

16) Уровни OSI - Open System Interconnection.
Модель OSI характеризует взаимодействие сетевого оборудования. Т.е. посредством нее общаются
такие устройства как ПК с сетевыми картами, коммутаторы, роутеры. 
Всего выделяется 7 уровней. 
1. Физический (Physical) - Ethernet как пример. 
здесь радиосигналы/электрические/оптические уходят от отправителя к получателю. Кодирование нулей и единиц.
2. Канальный уровень (Data link)
Мосты и коммутаторы. (такие термины как Фрейм и MAC-адрес).
3. Сетевой уровень (Network)
Роутер/маршрутизатор
Пакет данных.
Термины маршрутизация, IP-адрес. Здесь MAC-адрес --> через ARP --> в IP-адрес. 
Пользователь хочет зайти на сайт, вводит его адрес, отправляется DNS-запрос -->
приходит ответ в виде IP-адреса, который подставляется в пакет.
4. Транспортный уровень (Transport)
Происходит доставка информации по каналам внешней сети. 
Протоколы TCP(проверяет, чтобы данные были доставлены - e-mail)/UPD (не проверяет - Games).
5. Сеансовый уровень (Session)
Когда мы логинимся - появляется сеанс. Этот уровень в ответе за организацию сеансов, связи между приложениями
на компьютерах. Отвечает за создание и окончание сеанса, обмен данными, синхронизацию.
6. Уровень представления (Presentetion)
Преобразование форматов данных. Сжатие, кодирование. 
7. Уровень приложений (Application)
Верхний уровень, где располагаются сетевые службы. 
Описывает взаимосвязь приложений на ПК и внешней сети (HTTPS, HTTP, SMTP, POP3, FTP, Modbus..)

Передача с верхнего на нижний - инкапсуляция данных.
В обратной порядке - декапсуляция. 

17) Хедеры http запросов

HTTP Клиент (или просто Клиент)
Инструмент, который используется для взаимодействия с REST API. 
Этот инструмент позволяет создавать HTTP запросы и умеет обрабатывать полученные ответы.
Таким инструментом может быть:
Postman — программа или расширение для Chrome.
REST Easy — расширение для Firefox для тестирования запросов в браузере
httpie — тестирование запросов в командной строке.
WordPress HTTP API — клиент самого WordPress. Его, например, можно использовать для доступа к одному сайту WordPress с другого.


